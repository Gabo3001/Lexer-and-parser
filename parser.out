Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON programT
Rule 2     programT -> vars programF
Rule 3     programT -> programF
Rule 4     programF -> bloque empty
Rule 5     vars -> VAR varsT
Rule 6     varsT -> ID COMMA varsT
Rule 7     varsT -> ID COLON tipo SEMICOLON varsF
Rule 8     varsF -> varsT
Rule 9     varsF -> empty
Rule 10    tipo -> INT empty
Rule 11    tipo -> FLOAT empty
Rule 12    bloque -> L_CURPAR bloqueT
Rule 13    bloqueT -> estatuto bloqueT
Rule 14    bloqueT -> R_CURPAR empty
Rule 15    estatuto -> asignacion empty
Rule 16    estatuto -> condicion empty
Rule 17    estatuto -> escritura empty
Rule 18    asignacion -> ID EQ expresion SEMICOLON empty
Rule 19    escritura -> PRINT L_PAR escrituraT
Rule 20    escrituraT -> expresion escrituraF
Rule 21    escrituraT -> STRING escrituraF
Rule 22    escrituraF -> COMMA escrituraT
Rule 23    escrituraF -> R_PAR SEMICOLON empty
Rule 24    expresion -> exp expresionT
Rule 25    expresionT -> LESS exp empty
Rule 26    expresionT -> GREATER exp empty
Rule 27    expresionT -> DIF exp empty
Rule 28    expresionT -> empty
Rule 29    condicion -> IF L_PAR expresion R_PAR bloque condicionT
Rule 30    condicionT -> ELSE bloque empty
Rule 31    condicionT -> empty
Rule 32    exp -> termino expT
Rule 33    expT -> PLUS exp
Rule 34    expT -> MINUS exp
Rule 35    expT -> empty
Rule 36    termino -> factor terminoT
Rule 37    terminoT -> MULT termino
Rule 38    terminoT -> DIV termino
Rule 39    terminoT -> empty
Rule 40    factor -> L_PAR expresion R_PAR empty
Rule 41    factor -> factorT
Rule 42    factorT -> PLUS factorF
Rule 43    factorT -> MINUS factorF
Rule 44    factorT -> factorF
Rule 45    factorF -> varcte empty
Rule 46    varcte -> ID empty
Rule 47    varcte -> INT empty
Rule 48    varcte -> FLOAT empty
Rule 49    empty -> <empty>

Terminals, with rules where they appear

COLON                : 7
COMMA                : 6 22
DIF                  : 27
DIV                  : 38
ELSE                 : 30
EQ                   : 18
FLOAT                : 11 48
GREATER              : 26
ID                   : 1 6 7 18 46
IF                   : 29
INT                  : 10 47
LESS                 : 25
L_CURPAR             : 12
L_PAR                : 19 29 40
MINUS                : 34 43
MULT                 : 37
PLUS                 : 33 42
PRINT                : 19
PROGRAM              : 1
R_CURPAR             : 14
R_PAR                : 23 29 40
SEMICOLON            : 1 7 18 23
STRING               : 21
VAR                  : 5
error                : 

Nonterminals, with rules where they appear

asignacion           : 15
bloque               : 4 29 30
bloqueT              : 12 13
condicion            : 16
condicionT           : 29
empty                : 4 9 10 11 14 15 16 17 18 23 25 26 27 28 30 31 35 39 40 45 46 47 48
escritura            : 17
escrituraF           : 20 21
escrituraT           : 19 22
estatuto             : 13
exp                  : 24 25 26 27 33 34
expT                 : 32
expresion            : 18 20 29 40
expresionT           : 24
factor               : 36
factorF              : 42 43 44
factorT              : 41
program              : 0
programF             : 2 3
programT             : 1
termino              : 32 37 38
terminoT             : 36
tipo                 : 7
varcte               : 45
vars                 : 2
varsF                : 7
varsT                : 5 6 8

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON programT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON programT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON programT

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . programT
    (2) programT -> . vars programF
    (3) programT -> . programF
    (5) vars -> . VAR varsT
    (4) programF -> . bloque empty
    (12) bloque -> . L_CURPAR bloqueT

    VAR             shift and go to state 8
    L_CURPAR        shift and go to state 10

    programT                       shift and go to state 5
    vars                           shift and go to state 6
    programF                       shift and go to state 7
    bloque                         shift and go to state 9

state 5

    (1) program -> PROGRAM ID SEMICOLON programT .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON programT .)


state 6

    (2) programT -> vars . programF
    (4) programF -> . bloque empty
    (12) bloque -> . L_CURPAR bloqueT

    L_CURPAR        shift and go to state 10

    programF                       shift and go to state 11
    bloque                         shift and go to state 9

state 7

    (3) programT -> programF .

    $end            reduce using rule 3 (programT -> programF .)


state 8

    (5) vars -> VAR . varsT
    (6) varsT -> . ID COMMA varsT
    (7) varsT -> . ID COLON tipo SEMICOLON varsF

    ID              shift and go to state 13

    varsT                          shift and go to state 12

state 9

    (4) programF -> bloque . empty
    (49) empty -> .

    $end            reduce using rule 49 (empty -> .)

    empty                          shift and go to state 14

state 10

    (12) bloque -> L_CURPAR . bloqueT
    (13) bloqueT -> . estatuto bloqueT
    (14) bloqueT -> . R_CURPAR empty
    (15) estatuto -> . asignacion empty
    (16) estatuto -> . condicion empty
    (17) estatuto -> . escritura empty
    (18) asignacion -> . ID EQ expresion SEMICOLON empty
    (29) condicion -> . IF L_PAR expresion R_PAR bloque condicionT
    (19) escritura -> . PRINT L_PAR escrituraT

    R_CURPAR        shift and go to state 17
    ID              shift and go to state 21
    IF              shift and go to state 22
    PRINT           shift and go to state 23

    bloqueT                        shift and go to state 15
    estatuto                       shift and go to state 16
    asignacion                     shift and go to state 18
    condicion                      shift and go to state 19
    escritura                      shift and go to state 20

state 11

    (2) programT -> vars programF .

    $end            reduce using rule 2 (programT -> vars programF .)


state 12

    (5) vars -> VAR varsT .

    L_CURPAR        reduce using rule 5 (vars -> VAR varsT .)


state 13

    (6) varsT -> ID . COMMA varsT
    (7) varsT -> ID . COLON tipo SEMICOLON varsF

    COMMA           shift and go to state 24
    COLON           shift and go to state 25


state 14

    (4) programF -> bloque empty .

    $end            reduce using rule 4 (programF -> bloque empty .)


state 15

    (12) bloque -> L_CURPAR bloqueT .

    $end            reduce using rule 12 (bloque -> L_CURPAR bloqueT .)
    ELSE            reduce using rule 12 (bloque -> L_CURPAR bloqueT .)
    R_CURPAR        reduce using rule 12 (bloque -> L_CURPAR bloqueT .)
    ID              reduce using rule 12 (bloque -> L_CURPAR bloqueT .)
    IF              reduce using rule 12 (bloque -> L_CURPAR bloqueT .)
    PRINT           reduce using rule 12 (bloque -> L_CURPAR bloqueT .)


state 16

    (13) bloqueT -> estatuto . bloqueT
    (13) bloqueT -> . estatuto bloqueT
    (14) bloqueT -> . R_CURPAR empty
    (15) estatuto -> . asignacion empty
    (16) estatuto -> . condicion empty
    (17) estatuto -> . escritura empty
    (18) asignacion -> . ID EQ expresion SEMICOLON empty
    (29) condicion -> . IF L_PAR expresion R_PAR bloque condicionT
    (19) escritura -> . PRINT L_PAR escrituraT

    R_CURPAR        shift and go to state 17
    ID              shift and go to state 21
    IF              shift and go to state 22
    PRINT           shift and go to state 23

    estatuto                       shift and go to state 16
    bloqueT                        shift and go to state 26
    asignacion                     shift and go to state 18
    condicion                      shift and go to state 19
    escritura                      shift and go to state 20

state 17

    (14) bloqueT -> R_CURPAR . empty
    (49) empty -> .

    $end            reduce using rule 49 (empty -> .)
    ELSE            reduce using rule 49 (empty -> .)
    R_CURPAR        reduce using rule 49 (empty -> .)
    ID              reduce using rule 49 (empty -> .)
    IF              reduce using rule 49 (empty -> .)
    PRINT           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 27

state 18

    (15) estatuto -> asignacion . empty
    (49) empty -> .

    R_CURPAR        reduce using rule 49 (empty -> .)
    ID              reduce using rule 49 (empty -> .)
    IF              reduce using rule 49 (empty -> .)
    PRINT           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 28

state 19

    (16) estatuto -> condicion . empty
    (49) empty -> .

    R_CURPAR        reduce using rule 49 (empty -> .)
    ID              reduce using rule 49 (empty -> .)
    IF              reduce using rule 49 (empty -> .)
    PRINT           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 29

state 20

    (17) estatuto -> escritura . empty
    (49) empty -> .

    R_CURPAR        reduce using rule 49 (empty -> .)
    ID              reduce using rule 49 (empty -> .)
    IF              reduce using rule 49 (empty -> .)
    PRINT           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 30

state 21

    (18) asignacion -> ID . EQ expresion SEMICOLON empty

    EQ              shift and go to state 31


state 22

    (29) condicion -> IF . L_PAR expresion R_PAR bloque condicionT

    L_PAR           shift and go to state 32


state 23

    (19) escritura -> PRINT . L_PAR escrituraT

    L_PAR           shift and go to state 33


state 24

    (6) varsT -> ID COMMA . varsT
    (6) varsT -> . ID COMMA varsT
    (7) varsT -> . ID COLON tipo SEMICOLON varsF

    ID              shift and go to state 13

    varsT                          shift and go to state 34

state 25

    (7) varsT -> ID COLON . tipo SEMICOLON varsF
    (10) tipo -> . INT empty
    (11) tipo -> . FLOAT empty

    INT             shift and go to state 36
    FLOAT           shift and go to state 37

    tipo                           shift and go to state 35

state 26

    (13) bloqueT -> estatuto bloqueT .

    $end            reduce using rule 13 (bloqueT -> estatuto bloqueT .)
    ELSE            reduce using rule 13 (bloqueT -> estatuto bloqueT .)
    R_CURPAR        reduce using rule 13 (bloqueT -> estatuto bloqueT .)
    ID              reduce using rule 13 (bloqueT -> estatuto bloqueT .)
    IF              reduce using rule 13 (bloqueT -> estatuto bloqueT .)
    PRINT           reduce using rule 13 (bloqueT -> estatuto bloqueT .)


state 27

    (14) bloqueT -> R_CURPAR empty .

    $end            reduce using rule 14 (bloqueT -> R_CURPAR empty .)
    ELSE            reduce using rule 14 (bloqueT -> R_CURPAR empty .)
    R_CURPAR        reduce using rule 14 (bloqueT -> R_CURPAR empty .)
    ID              reduce using rule 14 (bloqueT -> R_CURPAR empty .)
    IF              reduce using rule 14 (bloqueT -> R_CURPAR empty .)
    PRINT           reduce using rule 14 (bloqueT -> R_CURPAR empty .)


state 28

    (15) estatuto -> asignacion empty .

    R_CURPAR        reduce using rule 15 (estatuto -> asignacion empty .)
    ID              reduce using rule 15 (estatuto -> asignacion empty .)
    IF              reduce using rule 15 (estatuto -> asignacion empty .)
    PRINT           reduce using rule 15 (estatuto -> asignacion empty .)


state 29

    (16) estatuto -> condicion empty .

    R_CURPAR        reduce using rule 16 (estatuto -> condicion empty .)
    ID              reduce using rule 16 (estatuto -> condicion empty .)
    IF              reduce using rule 16 (estatuto -> condicion empty .)
    PRINT           reduce using rule 16 (estatuto -> condicion empty .)


state 30

    (17) estatuto -> escritura empty .

    R_CURPAR        reduce using rule 17 (estatuto -> escritura empty .)
    ID              reduce using rule 17 (estatuto -> escritura empty .)
    IF              reduce using rule 17 (estatuto -> escritura empty .)
    PRINT           reduce using rule 17 (estatuto -> escritura empty .)


state 31

    (18) asignacion -> ID EQ . expresion SEMICOLON empty
    (24) expresion -> . exp expresionT
    (32) exp -> . termino expT
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    expresion                      shift and go to state 39
    exp                            shift and go to state 40
    termino                        shift and go to state 41
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 32

    (29) condicion -> IF L_PAR . expresion R_PAR bloque condicionT
    (24) expresion -> . exp expresionT
    (32) exp -> . termino expT
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    expresion                      shift and go to state 51
    exp                            shift and go to state 40
    termino                        shift and go to state 41
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 33

    (19) escritura -> PRINT L_PAR . escrituraT
    (20) escrituraT -> . expresion escrituraF
    (21) escrituraT -> . STRING escrituraF
    (24) expresion -> . exp expresionT
    (32) exp -> . termino expT
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    STRING          shift and go to state 54
    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    escrituraT                     shift and go to state 52
    expresion                      shift and go to state 53
    exp                            shift and go to state 40
    termino                        shift and go to state 41
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 34

    (6) varsT -> ID COMMA varsT .

    L_CURPAR        reduce using rule 6 (varsT -> ID COMMA varsT .)


state 35

    (7) varsT -> ID COLON tipo . SEMICOLON varsF

    SEMICOLON       shift and go to state 55


state 36

    (10) tipo -> INT . empty
    (49) empty -> .

    SEMICOLON       reduce using rule 49 (empty -> .)

    empty                          shift and go to state 56

state 37

    (11) tipo -> FLOAT . empty
    (49) empty -> .

    SEMICOLON       reduce using rule 49 (empty -> .)

    empty                          shift and go to state 57

state 38

    (46) varcte -> ID . empty
    (49) empty -> .

    MULT            reduce using rule 49 (empty -> .)
    DIV             reduce using rule 49 (empty -> .)
    PLUS            reduce using rule 49 (empty -> .)
    MINUS           reduce using rule 49 (empty -> .)
    LESS            reduce using rule 49 (empty -> .)
    GREATER         reduce using rule 49 (empty -> .)
    DIF             reduce using rule 49 (empty -> .)
    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 58

state 39

    (18) asignacion -> ID EQ expresion . SEMICOLON empty

    SEMICOLON       shift and go to state 59


state 40

    (24) expresion -> exp . expresionT
    (25) expresionT -> . LESS exp empty
    (26) expresionT -> . GREATER exp empty
    (27) expresionT -> . DIF exp empty
    (28) expresionT -> . empty
    (49) empty -> .

    LESS            shift and go to state 61
    GREATER         shift and go to state 63
    DIF             shift and go to state 64
    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    expresionT                     shift and go to state 60
    empty                          shift and go to state 62

state 41

    (32) exp -> termino . expT
    (33) expT -> . PLUS exp
    (34) expT -> . MINUS exp
    (35) expT -> . empty
    (49) empty -> .

    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    LESS            reduce using rule 49 (empty -> .)
    GREATER         reduce using rule 49 (empty -> .)
    DIF             reduce using rule 49 (empty -> .)
    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    expT                           shift and go to state 65
    empty                          shift and go to state 68

state 42

    (36) termino -> factor . terminoT
    (37) terminoT -> . MULT termino
    (38) terminoT -> . DIV termino
    (39) terminoT -> . empty
    (49) empty -> .

    MULT            shift and go to state 70
    DIV             shift and go to state 71
    PLUS            reduce using rule 49 (empty -> .)
    MINUS           reduce using rule 49 (empty -> .)
    LESS            reduce using rule 49 (empty -> .)
    GREATER         reduce using rule 49 (empty -> .)
    DIF             reduce using rule 49 (empty -> .)
    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    terminoT                       shift and go to state 69
    empty                          shift and go to state 72

state 43

    (40) factor -> L_PAR . expresion R_PAR empty
    (24) expresion -> . exp expresionT
    (32) exp -> . termino expT
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    expresion                      shift and go to state 73
    exp                            shift and go to state 40
    termino                        shift and go to state 41
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 44

    (41) factor -> factorT .

    MULT            reduce using rule 41 (factor -> factorT .)
    DIV             reduce using rule 41 (factor -> factorT .)
    PLUS            reduce using rule 41 (factor -> factorT .)
    MINUS           reduce using rule 41 (factor -> factorT .)
    LESS            reduce using rule 41 (factor -> factorT .)
    GREATER         reduce using rule 41 (factor -> factorT .)
    DIF             reduce using rule 41 (factor -> factorT .)
    SEMICOLON       reduce using rule 41 (factor -> factorT .)
    R_PAR           reduce using rule 41 (factor -> factorT .)
    COMMA           reduce using rule 41 (factor -> factorT .)


state 45

    (42) factorT -> PLUS . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    factorF                        shift and go to state 74
    varcte                         shift and go to state 48

state 46

    (44) factorT -> factorF .

    MULT            reduce using rule 44 (factorT -> factorF .)
    DIV             reduce using rule 44 (factorT -> factorF .)
    PLUS            reduce using rule 44 (factorT -> factorF .)
    MINUS           reduce using rule 44 (factorT -> factorF .)
    LESS            reduce using rule 44 (factorT -> factorF .)
    GREATER         reduce using rule 44 (factorT -> factorF .)
    DIF             reduce using rule 44 (factorT -> factorF .)
    SEMICOLON       reduce using rule 44 (factorT -> factorF .)
    R_PAR           reduce using rule 44 (factorT -> factorF .)
    COMMA           reduce using rule 44 (factorT -> factorF .)


state 47

    (43) factorT -> MINUS . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    factorF                        shift and go to state 75
    varcte                         shift and go to state 48

state 48

    (45) factorF -> varcte . empty
    (49) empty -> .

    MULT            reduce using rule 49 (empty -> .)
    DIV             reduce using rule 49 (empty -> .)
    PLUS            reduce using rule 49 (empty -> .)
    MINUS           reduce using rule 49 (empty -> .)
    LESS            reduce using rule 49 (empty -> .)
    GREATER         reduce using rule 49 (empty -> .)
    DIF             reduce using rule 49 (empty -> .)
    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 76

state 49

    (47) varcte -> INT . empty
    (49) empty -> .

    MULT            reduce using rule 49 (empty -> .)
    DIV             reduce using rule 49 (empty -> .)
    PLUS            reduce using rule 49 (empty -> .)
    MINUS           reduce using rule 49 (empty -> .)
    LESS            reduce using rule 49 (empty -> .)
    GREATER         reduce using rule 49 (empty -> .)
    DIF             reduce using rule 49 (empty -> .)
    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 77

state 50

    (48) varcte -> FLOAT . empty
    (49) empty -> .

    MULT            reduce using rule 49 (empty -> .)
    DIV             reduce using rule 49 (empty -> .)
    PLUS            reduce using rule 49 (empty -> .)
    MINUS           reduce using rule 49 (empty -> .)
    LESS            reduce using rule 49 (empty -> .)
    GREATER         reduce using rule 49 (empty -> .)
    DIF             reduce using rule 49 (empty -> .)
    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 78

state 51

    (29) condicion -> IF L_PAR expresion . R_PAR bloque condicionT

    R_PAR           shift and go to state 79


state 52

    (19) escritura -> PRINT L_PAR escrituraT .

    R_CURPAR        reduce using rule 19 (escritura -> PRINT L_PAR escrituraT .)
    ID              reduce using rule 19 (escritura -> PRINT L_PAR escrituraT .)
    IF              reduce using rule 19 (escritura -> PRINT L_PAR escrituraT .)
    PRINT           reduce using rule 19 (escritura -> PRINT L_PAR escrituraT .)


state 53

    (20) escrituraT -> expresion . escrituraF
    (22) escrituraF -> . COMMA escrituraT
    (23) escrituraF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 81
    R_PAR           shift and go to state 82

    escrituraF                     shift and go to state 80

state 54

    (21) escrituraT -> STRING . escrituraF
    (22) escrituraF -> . COMMA escrituraT
    (23) escrituraF -> . R_PAR SEMICOLON empty

    COMMA           shift and go to state 81
    R_PAR           shift and go to state 82

    escrituraF                     shift and go to state 83

state 55

    (7) varsT -> ID COLON tipo SEMICOLON . varsF
    (8) varsF -> . varsT
    (9) varsF -> . empty
    (6) varsT -> . ID COMMA varsT
    (7) varsT -> . ID COLON tipo SEMICOLON varsF
    (49) empty -> .

    ID              shift and go to state 13
    L_CURPAR        reduce using rule 49 (empty -> .)

    varsF                          shift and go to state 84
    varsT                          shift and go to state 85
    empty                          shift and go to state 86

state 56

    (10) tipo -> INT empty .

    SEMICOLON       reduce using rule 10 (tipo -> INT empty .)


state 57

    (11) tipo -> FLOAT empty .

    SEMICOLON       reduce using rule 11 (tipo -> FLOAT empty .)


state 58

    (46) varcte -> ID empty .

    MULT            reduce using rule 46 (varcte -> ID empty .)
    DIV             reduce using rule 46 (varcte -> ID empty .)
    PLUS            reduce using rule 46 (varcte -> ID empty .)
    MINUS           reduce using rule 46 (varcte -> ID empty .)
    LESS            reduce using rule 46 (varcte -> ID empty .)
    GREATER         reduce using rule 46 (varcte -> ID empty .)
    DIF             reduce using rule 46 (varcte -> ID empty .)
    SEMICOLON       reduce using rule 46 (varcte -> ID empty .)
    R_PAR           reduce using rule 46 (varcte -> ID empty .)
    COMMA           reduce using rule 46 (varcte -> ID empty .)


state 59

    (18) asignacion -> ID EQ expresion SEMICOLON . empty
    (49) empty -> .

    R_CURPAR        reduce using rule 49 (empty -> .)
    ID              reduce using rule 49 (empty -> .)
    IF              reduce using rule 49 (empty -> .)
    PRINT           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 87

state 60

    (24) expresion -> exp expresionT .

    SEMICOLON       reduce using rule 24 (expresion -> exp expresionT .)
    R_PAR           reduce using rule 24 (expresion -> exp expresionT .)
    COMMA           reduce using rule 24 (expresion -> exp expresionT .)


state 61

    (25) expresionT -> LESS . exp empty
    (32) exp -> . termino expT
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    exp                            shift and go to state 88
    termino                        shift and go to state 41
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 62

    (28) expresionT -> empty .

    SEMICOLON       reduce using rule 28 (expresionT -> empty .)
    R_PAR           reduce using rule 28 (expresionT -> empty .)
    COMMA           reduce using rule 28 (expresionT -> empty .)


state 63

    (26) expresionT -> GREATER . exp empty
    (32) exp -> . termino expT
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    exp                            shift and go to state 89
    termino                        shift and go to state 41
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 64

    (27) expresionT -> DIF . exp empty
    (32) exp -> . termino expT
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    exp                            shift and go to state 90
    termino                        shift and go to state 41
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 65

    (32) exp -> termino expT .

    LESS            reduce using rule 32 (exp -> termino expT .)
    GREATER         reduce using rule 32 (exp -> termino expT .)
    DIF             reduce using rule 32 (exp -> termino expT .)
    SEMICOLON       reduce using rule 32 (exp -> termino expT .)
    R_PAR           reduce using rule 32 (exp -> termino expT .)
    COMMA           reduce using rule 32 (exp -> termino expT .)


state 66

    (33) expT -> PLUS . exp
    (32) exp -> . termino expT
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    exp                            shift and go to state 91
    termino                        shift and go to state 41
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 67

    (34) expT -> MINUS . exp
    (32) exp -> . termino expT
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    exp                            shift and go to state 92
    termino                        shift and go to state 41
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 68

    (35) expT -> empty .

    LESS            reduce using rule 35 (expT -> empty .)
    GREATER         reduce using rule 35 (expT -> empty .)
    DIF             reduce using rule 35 (expT -> empty .)
    SEMICOLON       reduce using rule 35 (expT -> empty .)
    R_PAR           reduce using rule 35 (expT -> empty .)
    COMMA           reduce using rule 35 (expT -> empty .)


state 69

    (36) termino -> factor terminoT .

    PLUS            reduce using rule 36 (termino -> factor terminoT .)
    MINUS           reduce using rule 36 (termino -> factor terminoT .)
    LESS            reduce using rule 36 (termino -> factor terminoT .)
    GREATER         reduce using rule 36 (termino -> factor terminoT .)
    DIF             reduce using rule 36 (termino -> factor terminoT .)
    SEMICOLON       reduce using rule 36 (termino -> factor terminoT .)
    R_PAR           reduce using rule 36 (termino -> factor terminoT .)
    COMMA           reduce using rule 36 (termino -> factor terminoT .)


state 70

    (37) terminoT -> MULT . termino
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    termino                        shift and go to state 93
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 71

    (38) terminoT -> DIV . termino
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    termino                        shift and go to state 94
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 72

    (39) terminoT -> empty .

    PLUS            reduce using rule 39 (terminoT -> empty .)
    MINUS           reduce using rule 39 (terminoT -> empty .)
    LESS            reduce using rule 39 (terminoT -> empty .)
    GREATER         reduce using rule 39 (terminoT -> empty .)
    DIF             reduce using rule 39 (terminoT -> empty .)
    SEMICOLON       reduce using rule 39 (terminoT -> empty .)
    R_PAR           reduce using rule 39 (terminoT -> empty .)
    COMMA           reduce using rule 39 (terminoT -> empty .)


state 73

    (40) factor -> L_PAR expresion . R_PAR empty

    R_PAR           shift and go to state 95


state 74

    (42) factorT -> PLUS factorF .

    MULT            reduce using rule 42 (factorT -> PLUS factorF .)
    DIV             reduce using rule 42 (factorT -> PLUS factorF .)
    PLUS            reduce using rule 42 (factorT -> PLUS factorF .)
    MINUS           reduce using rule 42 (factorT -> PLUS factorF .)
    LESS            reduce using rule 42 (factorT -> PLUS factorF .)
    GREATER         reduce using rule 42 (factorT -> PLUS factorF .)
    DIF             reduce using rule 42 (factorT -> PLUS factorF .)
    SEMICOLON       reduce using rule 42 (factorT -> PLUS factorF .)
    R_PAR           reduce using rule 42 (factorT -> PLUS factorF .)
    COMMA           reduce using rule 42 (factorT -> PLUS factorF .)


state 75

    (43) factorT -> MINUS factorF .

    MULT            reduce using rule 43 (factorT -> MINUS factorF .)
    DIV             reduce using rule 43 (factorT -> MINUS factorF .)
    PLUS            reduce using rule 43 (factorT -> MINUS factorF .)
    MINUS           reduce using rule 43 (factorT -> MINUS factorF .)
    LESS            reduce using rule 43 (factorT -> MINUS factorF .)
    GREATER         reduce using rule 43 (factorT -> MINUS factorF .)
    DIF             reduce using rule 43 (factorT -> MINUS factorF .)
    SEMICOLON       reduce using rule 43 (factorT -> MINUS factorF .)
    R_PAR           reduce using rule 43 (factorT -> MINUS factorF .)
    COMMA           reduce using rule 43 (factorT -> MINUS factorF .)


state 76

    (45) factorF -> varcte empty .

    MULT            reduce using rule 45 (factorF -> varcte empty .)
    DIV             reduce using rule 45 (factorF -> varcte empty .)
    PLUS            reduce using rule 45 (factorF -> varcte empty .)
    MINUS           reduce using rule 45 (factorF -> varcte empty .)
    LESS            reduce using rule 45 (factorF -> varcte empty .)
    GREATER         reduce using rule 45 (factorF -> varcte empty .)
    DIF             reduce using rule 45 (factorF -> varcte empty .)
    SEMICOLON       reduce using rule 45 (factorF -> varcte empty .)
    R_PAR           reduce using rule 45 (factorF -> varcte empty .)
    COMMA           reduce using rule 45 (factorF -> varcte empty .)


state 77

    (47) varcte -> INT empty .

    MULT            reduce using rule 47 (varcte -> INT empty .)
    DIV             reduce using rule 47 (varcte -> INT empty .)
    PLUS            reduce using rule 47 (varcte -> INT empty .)
    MINUS           reduce using rule 47 (varcte -> INT empty .)
    LESS            reduce using rule 47 (varcte -> INT empty .)
    GREATER         reduce using rule 47 (varcte -> INT empty .)
    DIF             reduce using rule 47 (varcte -> INT empty .)
    SEMICOLON       reduce using rule 47 (varcte -> INT empty .)
    R_PAR           reduce using rule 47 (varcte -> INT empty .)
    COMMA           reduce using rule 47 (varcte -> INT empty .)


state 78

    (48) varcte -> FLOAT empty .

    MULT            reduce using rule 48 (varcte -> FLOAT empty .)
    DIV             reduce using rule 48 (varcte -> FLOAT empty .)
    PLUS            reduce using rule 48 (varcte -> FLOAT empty .)
    MINUS           reduce using rule 48 (varcte -> FLOAT empty .)
    LESS            reduce using rule 48 (varcte -> FLOAT empty .)
    GREATER         reduce using rule 48 (varcte -> FLOAT empty .)
    DIF             reduce using rule 48 (varcte -> FLOAT empty .)
    SEMICOLON       reduce using rule 48 (varcte -> FLOAT empty .)
    R_PAR           reduce using rule 48 (varcte -> FLOAT empty .)
    COMMA           reduce using rule 48 (varcte -> FLOAT empty .)


state 79

    (29) condicion -> IF L_PAR expresion R_PAR . bloque condicionT
    (12) bloque -> . L_CURPAR bloqueT

    L_CURPAR        shift and go to state 10

    bloque                         shift and go to state 96

state 80

    (20) escrituraT -> expresion escrituraF .

    R_CURPAR        reduce using rule 20 (escrituraT -> expresion escrituraF .)
    ID              reduce using rule 20 (escrituraT -> expresion escrituraF .)
    IF              reduce using rule 20 (escrituraT -> expresion escrituraF .)
    PRINT           reduce using rule 20 (escrituraT -> expresion escrituraF .)


state 81

    (22) escrituraF -> COMMA . escrituraT
    (20) escrituraT -> . expresion escrituraF
    (21) escrituraT -> . STRING escrituraF
    (24) expresion -> . exp expresionT
    (32) exp -> . termino expT
    (36) termino -> . factor terminoT
    (40) factor -> . L_PAR expresion R_PAR empty
    (41) factor -> . factorT
    (42) factorT -> . PLUS factorF
    (43) factorT -> . MINUS factorF
    (44) factorT -> . factorF
    (45) factorF -> . varcte empty
    (46) varcte -> . ID empty
    (47) varcte -> . INT empty
    (48) varcte -> . FLOAT empty

    STRING          shift and go to state 54
    L_PAR           shift and go to state 43
    PLUS            shift and go to state 45
    MINUS           shift and go to state 47
    ID              shift and go to state 38
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    escrituraT                     shift and go to state 97
    expresion                      shift and go to state 53
    exp                            shift and go to state 40
    termino                        shift and go to state 41
    factor                         shift and go to state 42
    factorT                        shift and go to state 44
    factorF                        shift and go to state 46
    varcte                         shift and go to state 48

state 82

    (23) escrituraF -> R_PAR . SEMICOLON empty

    SEMICOLON       shift and go to state 98


state 83

    (21) escrituraT -> STRING escrituraF .

    R_CURPAR        reduce using rule 21 (escrituraT -> STRING escrituraF .)
    ID              reduce using rule 21 (escrituraT -> STRING escrituraF .)
    IF              reduce using rule 21 (escrituraT -> STRING escrituraF .)
    PRINT           reduce using rule 21 (escrituraT -> STRING escrituraF .)


state 84

    (7) varsT -> ID COLON tipo SEMICOLON varsF .

    L_CURPAR        reduce using rule 7 (varsT -> ID COLON tipo SEMICOLON varsF .)


state 85

    (8) varsF -> varsT .

    L_CURPAR        reduce using rule 8 (varsF -> varsT .)


state 86

    (9) varsF -> empty .

    L_CURPAR        reduce using rule 9 (varsF -> empty .)


state 87

    (18) asignacion -> ID EQ expresion SEMICOLON empty .

    R_CURPAR        reduce using rule 18 (asignacion -> ID EQ expresion SEMICOLON empty .)
    ID              reduce using rule 18 (asignacion -> ID EQ expresion SEMICOLON empty .)
    IF              reduce using rule 18 (asignacion -> ID EQ expresion SEMICOLON empty .)
    PRINT           reduce using rule 18 (asignacion -> ID EQ expresion SEMICOLON empty .)


state 88

    (25) expresionT -> LESS exp . empty
    (49) empty -> .

    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 99

state 89

    (26) expresionT -> GREATER exp . empty
    (49) empty -> .

    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 100

state 90

    (27) expresionT -> DIF exp . empty
    (49) empty -> .

    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 101

state 91

    (33) expT -> PLUS exp .

    LESS            reduce using rule 33 (expT -> PLUS exp .)
    GREATER         reduce using rule 33 (expT -> PLUS exp .)
    DIF             reduce using rule 33 (expT -> PLUS exp .)
    SEMICOLON       reduce using rule 33 (expT -> PLUS exp .)
    R_PAR           reduce using rule 33 (expT -> PLUS exp .)
    COMMA           reduce using rule 33 (expT -> PLUS exp .)


state 92

    (34) expT -> MINUS exp .

    LESS            reduce using rule 34 (expT -> MINUS exp .)
    GREATER         reduce using rule 34 (expT -> MINUS exp .)
    DIF             reduce using rule 34 (expT -> MINUS exp .)
    SEMICOLON       reduce using rule 34 (expT -> MINUS exp .)
    R_PAR           reduce using rule 34 (expT -> MINUS exp .)
    COMMA           reduce using rule 34 (expT -> MINUS exp .)


state 93

    (37) terminoT -> MULT termino .

    PLUS            reduce using rule 37 (terminoT -> MULT termino .)
    MINUS           reduce using rule 37 (terminoT -> MULT termino .)
    LESS            reduce using rule 37 (terminoT -> MULT termino .)
    GREATER         reduce using rule 37 (terminoT -> MULT termino .)
    DIF             reduce using rule 37 (terminoT -> MULT termino .)
    SEMICOLON       reduce using rule 37 (terminoT -> MULT termino .)
    R_PAR           reduce using rule 37 (terminoT -> MULT termino .)
    COMMA           reduce using rule 37 (terminoT -> MULT termino .)


state 94

    (38) terminoT -> DIV termino .

    PLUS            reduce using rule 38 (terminoT -> DIV termino .)
    MINUS           reduce using rule 38 (terminoT -> DIV termino .)
    LESS            reduce using rule 38 (terminoT -> DIV termino .)
    GREATER         reduce using rule 38 (terminoT -> DIV termino .)
    DIF             reduce using rule 38 (terminoT -> DIV termino .)
    SEMICOLON       reduce using rule 38 (terminoT -> DIV termino .)
    R_PAR           reduce using rule 38 (terminoT -> DIV termino .)
    COMMA           reduce using rule 38 (terminoT -> DIV termino .)


state 95

    (40) factor -> L_PAR expresion R_PAR . empty
    (49) empty -> .

    MULT            reduce using rule 49 (empty -> .)
    DIV             reduce using rule 49 (empty -> .)
    PLUS            reduce using rule 49 (empty -> .)
    MINUS           reduce using rule 49 (empty -> .)
    LESS            reduce using rule 49 (empty -> .)
    GREATER         reduce using rule 49 (empty -> .)
    DIF             reduce using rule 49 (empty -> .)
    SEMICOLON       reduce using rule 49 (empty -> .)
    R_PAR           reduce using rule 49 (empty -> .)
    COMMA           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 102

state 96

    (29) condicion -> IF L_PAR expresion R_PAR bloque . condicionT
    (30) condicionT -> . ELSE bloque empty
    (31) condicionT -> . empty
    (49) empty -> .

    ELSE            shift and go to state 104
    R_CURPAR        reduce using rule 49 (empty -> .)
    ID              reduce using rule 49 (empty -> .)
    IF              reduce using rule 49 (empty -> .)
    PRINT           reduce using rule 49 (empty -> .)

    condicionT                     shift and go to state 103
    empty                          shift and go to state 105

state 97

    (22) escrituraF -> COMMA escrituraT .

    R_CURPAR        reduce using rule 22 (escrituraF -> COMMA escrituraT .)
    ID              reduce using rule 22 (escrituraF -> COMMA escrituraT .)
    IF              reduce using rule 22 (escrituraF -> COMMA escrituraT .)
    PRINT           reduce using rule 22 (escrituraF -> COMMA escrituraT .)


state 98

    (23) escrituraF -> R_PAR SEMICOLON . empty
    (49) empty -> .

    R_CURPAR        reduce using rule 49 (empty -> .)
    ID              reduce using rule 49 (empty -> .)
    IF              reduce using rule 49 (empty -> .)
    PRINT           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 106

state 99

    (25) expresionT -> LESS exp empty .

    SEMICOLON       reduce using rule 25 (expresionT -> LESS exp empty .)
    R_PAR           reduce using rule 25 (expresionT -> LESS exp empty .)
    COMMA           reduce using rule 25 (expresionT -> LESS exp empty .)


state 100

    (26) expresionT -> GREATER exp empty .

    SEMICOLON       reduce using rule 26 (expresionT -> GREATER exp empty .)
    R_PAR           reduce using rule 26 (expresionT -> GREATER exp empty .)
    COMMA           reduce using rule 26 (expresionT -> GREATER exp empty .)


state 101

    (27) expresionT -> DIF exp empty .

    SEMICOLON       reduce using rule 27 (expresionT -> DIF exp empty .)
    R_PAR           reduce using rule 27 (expresionT -> DIF exp empty .)
    COMMA           reduce using rule 27 (expresionT -> DIF exp empty .)


state 102

    (40) factor -> L_PAR expresion R_PAR empty .

    MULT            reduce using rule 40 (factor -> L_PAR expresion R_PAR empty .)
    DIV             reduce using rule 40 (factor -> L_PAR expresion R_PAR empty .)
    PLUS            reduce using rule 40 (factor -> L_PAR expresion R_PAR empty .)
    MINUS           reduce using rule 40 (factor -> L_PAR expresion R_PAR empty .)
    LESS            reduce using rule 40 (factor -> L_PAR expresion R_PAR empty .)
    GREATER         reduce using rule 40 (factor -> L_PAR expresion R_PAR empty .)
    DIF             reduce using rule 40 (factor -> L_PAR expresion R_PAR empty .)
    SEMICOLON       reduce using rule 40 (factor -> L_PAR expresion R_PAR empty .)
    R_PAR           reduce using rule 40 (factor -> L_PAR expresion R_PAR empty .)
    COMMA           reduce using rule 40 (factor -> L_PAR expresion R_PAR empty .)


state 103

    (29) condicion -> IF L_PAR expresion R_PAR bloque condicionT .

    R_CURPAR        reduce using rule 29 (condicion -> IF L_PAR expresion R_PAR bloque condicionT .)
    ID              reduce using rule 29 (condicion -> IF L_PAR expresion R_PAR bloque condicionT .)
    IF              reduce using rule 29 (condicion -> IF L_PAR expresion R_PAR bloque condicionT .)
    PRINT           reduce using rule 29 (condicion -> IF L_PAR expresion R_PAR bloque condicionT .)


state 104

    (30) condicionT -> ELSE . bloque empty
    (12) bloque -> . L_CURPAR bloqueT

    L_CURPAR        shift and go to state 10

    bloque                         shift and go to state 107

state 105

    (31) condicionT -> empty .

    R_CURPAR        reduce using rule 31 (condicionT -> empty .)
    ID              reduce using rule 31 (condicionT -> empty .)
    IF              reduce using rule 31 (condicionT -> empty .)
    PRINT           reduce using rule 31 (condicionT -> empty .)


state 106

    (23) escrituraF -> R_PAR SEMICOLON empty .

    R_CURPAR        reduce using rule 23 (escrituraF -> R_PAR SEMICOLON empty .)
    ID              reduce using rule 23 (escrituraF -> R_PAR SEMICOLON empty .)
    IF              reduce using rule 23 (escrituraF -> R_PAR SEMICOLON empty .)
    PRINT           reduce using rule 23 (escrituraF -> R_PAR SEMICOLON empty .)


state 107

    (30) condicionT -> ELSE bloque . empty
    (49) empty -> .

    R_CURPAR        reduce using rule 49 (empty -> .)
    ID              reduce using rule 49 (empty -> .)
    IF              reduce using rule 49 (empty -> .)
    PRINT           reduce using rule 49 (empty -> .)

    empty                          shift and go to state 108

state 108

    (30) condicionT -> ELSE bloque empty .

    R_CURPAR        reduce using rule 30 (condicionT -> ELSE bloque empty .)
    ID              reduce using rule 30 (condicionT -> ELSE bloque empty .)
    IF              reduce using rule 30 (condicionT -> ELSE bloque empty .)
    PRINT           reduce using rule 30 (condicionT -> ELSE bloque empty .)

